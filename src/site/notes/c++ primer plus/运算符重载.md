---
{"dg-publish":true,"dg-permalink":"/cpp/运算符重载","title":"运算符重载","permalink":"/cpp/运算符重载/","dgPassFrontmatter":true}
---



# C++ `运算符重载`
运算符重载是 C++ 中的一项强大功能，允许我们为已有的运算符（如 `+`, `-`, `*`, `<<`, `>>` 等）定义自定义的行为。运算符重载使得我们可以像使用内置类型一样使用自定义类型的对象，从而提高代码的可读性和简洁性。

## 运算符重载的定义
运算符重载是通过为运算符定义特殊的函数来实现的。这些函数可以是 **成员函数** 或 **非成员函数**，具体取决于运算符的类型。

### 成员函数运算符重载
成员函数重载运算符通常用于类的对象之间的运算。运算符作为类的成员函数被定义，它通常会修改类的对象或返回类的对象。

#### 示例：重载 `+` 运算符
```cpp
class Complex {
public:
    int real, imag;

    Complex(int r, int i) : real(r), imag(i) {}

    // 重载 + 运算符
    Complex operator+(const Complex& other) {
        return Complex(real + other.real, imag + other.imag);
    }
};
```


### 非成员函数运算符重载
非成员函数重载运算符用于类的对象与其他类型的交互。常见的非成员运算符重载是输出流运算符 `<<` 和输入流运算符 `>>`。

#### 示例：重载输出流运算符 `<<`
```cpp
class Complex {
public:
    int real, imag;

    Complex(int r, int i) : real(r), imag(i) {}
};

// 非成员函数：重载 << 运算符（输出流）
std::ostream& operator<<(std::ostream& out, const Complex& c) {
    out << c.real << " + " << c.imag << "i";
    return out;
}

```


### 运算符重载规则
1. **不可以改变运算符的优先级和结合性**：运算符的优先级和结合性是固定的，不能通过重载进行更改。
2. **不可以重载某些运算符**：例如 `::`（作用域解析运算符）、`.*`（成员指针访问运算符）、`sizeof`（大小运算符）等。
3. **运算符的返回类型**：成员函数的运算符可以返回对象本身或者另一个对象。非成员函数则通常返回流对象（如 `std::ostream&`）。


## 常见的运算符重载

### 算术运算符
- `+`, `-`, `*`, `/`, `%`：用于实现算术运算。`


### 关系运算符
- `==`, `!=`, `<`, `>`, `<=`, `>=`：用于对象之间的比较。


### 赋值运算符
- `=`：用于对象赋值。


### 自增/自减运算符
- `++`, `--`：用于增加或减少对象的值。


### 下标运算符（`[]`）
- 用于模拟数组行为。


### 类型转换运算符
- `type()`：用于将对象转换为其他类型。


### 流运算符（`<<`, `>>`）
- 用于输入输出流。

cout智能调节,根源于<<运算符基于oop根据其后的数据类型相应的调节行为(运算符重载)[[#示例：重载输出流运算符 `<<`]]
